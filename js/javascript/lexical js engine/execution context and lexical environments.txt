execution context and lexical environments : 

	* syntax parser : read code - what it does, grammar valid
	* lexical environment : physically exist (where you write, what surrounds it) - variable inside a function
	* execution context : wrapper manage the code running (many functions - which one is running)
	* name value pair : single value.
	
Javascript engine : 

	* creates a global object and this 
	* browser : window is the global object, each tab has own global execution context - seperate global onbjects
	* nodejs : different global object as running on a server
	
global object: 

	* not inside a function : code is global
	* window.a gives value of "a"
	
	
create execution instance : 

	* 2 phases  phase 1: creation(global object, this, outer environment - parser runs the code and creates variables and functions - memory space(hoisting)), 
	* phase 2 : execution phase : assignments
	
	* In phase 1 - value unknown(not yet assigned) : placeholder : undefined
	* uncaught reference error - when not even assigned
	

single threaded : 

	* 1 command at a time - single threaded but browsers : not
	* synchronous : one at a time (finish and move on) in order - javascript
	
invoke function and execution stack : 

	* invoke -> run / call a function : run()
	* function b(){}
	  function a(){b();}
	  a();
	steps : 
		1. global execution context(window, this variable, setup memory)
		2. hits a(); invoked
		3. execution context for a() created and stcaked in execution stack
		stack : a(); b();(b on top - do b destroy b, complete a, destroy)
		
		
example : 

	function a(){b(); let c = 3;}
	function b(){let d;}
	a();var d;
	
global context : func a, b, variable d : created
invoke a -> stack
invoke b by a function : now execution context for that : var d creates when b() done destroyed(local variable)


step by step : 
	1. global object and this variable
	2. In global execution context : var d = undefined
	3. create a execution context, var c = undefined
	4. create b's execution context : create var c = undefined, destroy this context
	5. moving to a's exe context, assign c = 3, done : destroy conetxt of exe
	6. done with global objext, return 
	

var : 

	* js looks in current context and global context(outer environment)
	* each environment has access to global context environment
	
code :

	function a(){
		console.log(myvar);
	}

	function b(){
		a();
		var myvar = 2;
		a();
	}

	var myvar = 1;
	b();
	
	op : 1 1
	
	
note : not inside the b() but at same level as global environment
       can't find in current environment, find in global execution context(its lower level at lexical environment)
       
       
       
more : 

	* all functions are in same level as global environment until nested
	* so any function look down - get global lexical context
	
	
function a(){
	function b(){
		console.log("B");
	}
	var myvar = 2;
	b();
}

a();
//b(); (b is not same lexical space as global(inside a)) - unable to find

op : 2


if myvar = 2 is commented, js looks deepdown and finds myvar = 1 from global context



let : 

	* block scoping : only within block
	* good to use let
	
	
	
asynchronous ? how achieved : 

	* js engine of browser : multithread
	* async - runs outside js
	* everything inside js : synchronous
	
step by step : 

	* another : event queue(notifications)
	* when async calls made - notified - place in queue
	* put at queue, does functions keep going
	* when stack is empty - periodically look at queue : wait for something
	* if something there : execute queue items
	* queue won't be executed until - stack empty
